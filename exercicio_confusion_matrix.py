# -*- coding: utf-8 -*-
"""Exercicio_Confusion_Matrix.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xiEDPDnhEum0zBgptSEE31OnV3M2Sy80
"""

!pip install tensorflow tensorflow-datasets keras

import os
import io
import random
import numpy as np
import pandas as pd
import keras
import tensorflow as tf
import matplotlib.pyplot as plt
import seaborn as sns
import tensorflow_datasets as tfds
import sklearn
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.utils import to_categorical
from tensorflow.keras import layers, models, datasets
from tensorflow.keras.models import Sequential
from tensorflow.keras.callbacks import TensorBoard
from sklearn.metrics import recall_score, precision_score, f1_score

# Configuração do TensorFlow para evitar problemas de memória
os.environ["CUDA_VISIBLE_DEVICES"] = "-1"  # Forçar uso da CPU
os.environ['TF_FORCE_GPU_ALLOW_GROWTH'] = 'true'

print(f"TensorFlow Version: {tf.__version__}")

tf.config.run_functions_eagerly(True)

(train_images, train_labels), (test_images, test_labels) = datasets.mnist.load_data()

train_images = train_images.reshape((60000, 28, 28, 1))
test_images = test_images.reshape((10000, 28, 28, 1))

train_images, test_images = train_images / 255.0, test_images / 255.0

classes=[0,1,2,3,4,5,6,7,8,9]

print(type(train_images), train_images.shape)
print(type(train_labels), train_labels.shape)

# Criar modelo de rede neural convolucional
model = models.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.Flatten(),
    layers.Dense(64, activation='relu'),
    layers.Dense(10, activation='softmax')
])

print(model.summary())

# Callback para o TensorBoard
logdir = "logs"
tensorboard_callback = TensorBoard(log_dir=logdir, histogram_freq=1)

print(type(train_images), train_images.shape)
print(type(train_labels), train_labels.shape)

print(train_images.shape)

# Compilar o modelo
model.compile(loss='sparse_categorical_crossentropy',
              optimizer='adam',
              metrics=['accuracy'])

# Treinar o modelo
model.fit(train_images, train_labels, epochs=5, callbacks=[tensorboard_callback])

# Avaliação do modelo
loss, accuracy = model.evaluate(test_images, test_labels, verbose=0)
print(f'Loss: {loss:.4f}, Accuracy: {accuracy:.4f}')

# Fazer previsões
y_pred = np.argmax(model.predict(test_images), axis=-1)

# Criar matriz de confusão
con_mat = tf.math.confusion_matrix(labels=test_labels, predictions=y_pred).numpy()
con_mat_norm = np.around(con_mat.astype('float') / con_mat.sum(axis=1)[:, np.newaxis], decimals=2)

# Criar DataFrame para visualização
classes = list(range(10))
con_mat_df = pd.DataFrame(con_mat_norm, index=classes, columns=classes)

figure = plt.figure(figsize=(8, 8))
sns.heatmap(con_mat_df, annot=True,cmap=plt.cm.Blues)
plt.tight_layout()
plt.ylabel('True label')
plt.xlabel('Predicted label')
plt.show()

# Sensibilidade (Recall)
recall = recall_score(test_labels, y_pred, average='macro')
print(f"Sensibilidade (Recall): {recall:.2f}")

# Especificidade
tn = con_mat[0, 0]  # True Negative
fp = con_mat[0, 1]  # False Positive
specificity = tn / (tn + fp)
print(f"Especificidade: {specificity:.2f}")

# Precisão
precision = precision_score(test_labels, y_pred, average='macro')
print(f"Precisão: {precision:.2f}")

# F1-Score
f1 = f1_score(test_labels, y_pred, average='macro')
print(f"F1-Score: {f1:.2f}")